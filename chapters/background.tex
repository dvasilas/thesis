\section{Query Processing in Relational Database Systems}

\section{NoSQL Datastores}

\subsection{NoSQL Data models}

\subsection{Partitioning}
\label{sec:partitioning}

\subsection{Replication}

\subsection{Secondary indexes}

\subsubsection{Partitioning and Secondary Indexes}

The partitioning schemes discussed in \ref{sec:partitioning} rely on a key-value data model.
Secondary indexes do not neatly map to the partitioning technique:
a secondary index usually does not uniquely identify a data item, but rather provides a way of searching for occurrences
of a particular value.

There are two main approaches to partitioning a secondary index:
document-based partitioning and term-based partitioning.

The terminology used in the rest of this section comes from the literature of full-text indexes (a particular kind of secondary index):
a document is a self-contained piece of information, that is composed of terms.

\bigskip

\noindent
\textbf{Partitioning Indexes by Document.}
In this approach, each partition is separate:
each partition maintains its own secondary indexes, covering only documents in that partition.
A document-partitioned index is also known as a \textit{local index}.

When this approach is used, each database write (adding, removing, or updating a document) is handled only by the
partition that contains the corresponding document.
However, reading from a document-partitioned index requires a scatter/gather approach:
sending the query to all partitions, and combining the returned results.
This can make index lookups quite expensive.
Even if index lookup requests are sent to partitions in parallel, scatter/gather is prone to tail latency amplification,
as the total latency depends from the latency of the slowest index partition.

This approach is widely used: MongoDB, Riak \cite{riakv:secondaryindexes}, Cassandra \cite{cassandra:secondaryindexing}
Elasticsearch \cite{elastic:docrouting}, Solr \cite{solr:indexsharding}.

\bigskip

\noindent
\textbf{Partitioning Secondary Indexes by Term.}
An alternative approach is to construct a \textit{global index} that covers data in all partitions.
A global index, however, also needs to be partitioned, as storing it on one node would likely become a bottleneck.

To partition a global index, the indexed terms can be used as the partition key (thus the term \textit{term-partitioned}
index).
Same as in base data partitioning, the index partitioning scheme can use the terms themselves, which can be useful for
range scans, or a the terms' hashes, which results to a more even load distribution.

The advantage of a term-partitioned index is that it can make reads more efficient:
rather than requiring a scatter/gather over all partitions, a lookup for a given term only needs to make a request to the
partition containing that term.
The downside of this approach is that writes are more complicated and slower:
a write to a single document may affect multiple partitions, the document's terms may be on different partitions.

DynamoDB supports both global and local secondary indexes \cite{dynamodb:secondaryindexes}.
Global indexing has also been used in the research systems such as SLIK \cite{kejriwal:slik} and Diff-Index \cite{tan:diffindex}.

\bigskip
TODO: discuss routing on the two approaches.

TODO:
% https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html
% When you put or delete items in a table, the global secondary indexes on that table are updated in an eventually consistent fashion. Changes to the table data are propagated to the global secondary indexes within a fraction of a second, under normal conditions. However, in some unlikely failure scenarios, longer propagation delays might occur. Because of this, your applications need to anticipate and handle situations where a query on a global secondary index returns results that are not up to date.

\bibliographystyle{plainnat}
\bibliography{refs}