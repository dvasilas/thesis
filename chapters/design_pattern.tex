
In this chapter we present our main contribution,
a \textit{design pattern} for building query processing systems with the goal of evolving query processing
system's architecture from monolithic and static to modular and flexible.

Traditional static query processing systems are not able to cater to the needs of modern applications in which users and
data are geo-distributed across the globe.
Our vision is to enable query processing systems that are designed and deployed on a case-by-case basis,
with the workload characteristics, data and access distribution patterns, and requirements of specific applications in
mind.

As a first step towards this vision, we focus on the \textit{mechanisms} required for enabling a flexible and configurable
query processing system architecture.

The design pattern that we propose is based on the following objectives:
\begin{itemize}
  \item \textbf{Decoupling between storage and query processing architecture.}
  The design pattern should be based on architecture, mechanism or interface of a specific data storage tier.
  Instead, it should enable query processing system to work as middleware systems on top of existing database systems.

  \item \textbf{Independence from corpus partitioning and distribution schemes.}
  The design pattern should not be based on specific a partitioning and distribution scheme for the corpus,
  but rather enable the construction of query processing systems compatible with multiple different
  data partitioning or distribution schemes.

  \item \textbf{Tunability.}
  The query processing should be able to be configured on the following dimensions:
  \begin{itemize}
    \item Index and view materialization:
    The query processing system should enable database to create secondary indexes and materialized views.
    Additionally, the index data structure used for indexes should be configurable.
    \item Caching:
    Similarly, the use of caches should be configuration-based.
    \item State maintenance scheme:
    The mode (synchronous or asynchronous) of incrementally applying corpus update to indexes and materialized views,
    should be configurable in a per index/view basis.
    \item State partitioning scheme:
    Similarly, the partitioning scheme used for secondary indexes and materialized views should be configurable in a per
    index/view basis.
  \end{itemize}

  \item \textbf{Flexible state and computation placement.}
  The design pattern should enable fine-grained control over the placement of the query processing system's derived state
  and computations.

\end{itemize}

\section{Overview: composable query processing system architecture}

The key idea for achieving the objectives described above is \textit{assembly-based modularity}
\cite{leclercq:dream, bouget:pleiades}.
A query processing system is constructed by interconnecting composable building blocks
that encapsulate derived state structures, such as indexes, materialized views, and caches,
as well as relational operators such as filters, aggregations, and joins.
In that way, configuration choices, such as index and view materialization, cache, and derived state partitioning,
translate to \textit{composition choices}: which building blocks are used and how they are interconnected.
For example, adding a caching layer to an existing query processing system can be done by extending an existing
architecture with additional ``caching'' building blocks.

Moreover, the query processing architecture's building blocks separate interface from implementation.
Because the query processing system's components communicate through well-defined interfaces,
they can be flexibly placed across the system infrastructure.
As a result, a given query processing system architecture can support multiple different component placement schemes.

\bigskip
\noindent
This design pattern defines a \textbf{modular} and \textbf{composable} component-based query processing system
architecture.
The principal element of this architecture, is its building block, which we term Query Processing Unit (QPU).

A QPU is a \textit{system component} that combines properties of a streaming operator and a microservice.
Similarly to a streaming operator, a QPU receives one or more input streams, performs a computation over these streams,
and emits an output stream.
Similarly to a microservice, a QPU provides its functionality by exposing an interface for receiving requests
(called \textit{query requests})
and can interoperate with other QPUs by sending query requests to them.
The response to query request is a stream:
every input stream that one QPU $A$ receives is the output stream of another QPU $B$, and is the response to a query request
that $A$ has sent to $B$.

\medskip
\noindent
A query processing unit can encapsulate a \textit{relational operator}.
For example, a ``join operator'' QPU receives input streams that represent the tables to be joined,
and emits an output stream that represents the results of the join operation on these tables.

Moreover, a QPU can encapsulate a \textit{derived state structure}, such as an index, a materialized view, or a cache.
For example, a ``secondary index'' QPU receives an input stream that represents notifications for updates to that table
at the corpus.
It maintains a secondary index data structure, which it stores as internal state.
When it receives a query request, it reads from its internal state and emits the result as an output stream.

Finally, a QPU can encapsulate a responsible for managing access to components of the query processing system, such as
a partition or replica manager, or a load balancer.
For example ``partition manager'' QPU, responsible for managing access to the partitions of a partitioned secondary index
(each index partition being encapsulated by a QPU), sends query requests to the appropriate index partitions for a given
query, and merges the resulting streams.

Our key insight is that all three of the described QPU types --- relational operators, derived state, and routing operators ---
can be generalized to a system component with common semantics, and thus can be composed in order to implement higher-level
query processing computations.

\medskip
\noindent
QPUs are organized in a directed acyclic graph.
The edges of the graph represent potential query request - response steam relations.
For example, an edge from a QPU $A$ to $B$ indicates that $A$ can send query requests to
--- and therefore establish input streams from --- $B$.
We call $B$ a \textit{downstream connection} of $A$, and a query request sent from $A$ to $B$ a \textit{downstream query}.
Base data are the leaves of the graph (nodes with only incoming edges),
and client queries enter the graph through its root nodes (nodes with outgoing edges).

When a QPU receives a query, it can either process it by reading from its internal state, or establish input streams
by sending query requests to its some of its downstream connections and produce query results by performing a
computation over these streams,
or a combination of the two.
As each QPU send query requests to its downstream connections,
this process is repeated at each QPU that receives a query request.
In that way, a client query results to query requests flowing downwards through the query processing system's QPU graph,
defining a \textit{query execution sub-graph}.
Query result stream flow upwards through the edge of this sub-graph.


\section{Query processing unit: a building block for composable query processing architectures}

\subsection{The Query Processing Unit component model}

The key requirement for the query processing unit is \textit{composability}:
QPUs should be able to be interconnected in various topologies,
and to interoperate in the execution of query processing tasks.

To achieve this, we define a common set of properties that every query processing unit should conform to.
This properties include the QPU's interface for receiving query requests, and the query request - response stream semantics.
We call this set of properties the query processing unit \textit{component model} (QPU model for short).
Using object-oriented programming terminology, the QPU model can be viewed as an \textit{abstract class}
that defines a set of method signatures, but not their implementation.
Implementations of the QPU model define \textit{QPU classes} with specific functionalities, for example
filter, join or materialized view QPU classes.
Using the object-oriented programming analogy, QPU classes can be viewed as classes that implement the QPU
abstract class.
Finally, specific \textit{QPU instances} can be viewed as objects of a specific QPU class, for example a secondary
index QPU for the attribute $predominantColor$ of the table $photoAlbum$.
According to the proposed design pattern, query processing systems are composed of QPU instances.

In the rest of this thesis we use the terms query processing unit, QPU, and unit interchangeably to refer to QPU instances.

\bigskip
\noindent
In this section we present an overview of the QPU model, with the goal of introducing the main concepts.
In section~\ref{ref:specification} we present the detailed specification of the QPU model.

The query processing unit component model defines a \textit{system component} with the following properties:

\begin{figure}[t]
  \centering
    \includegraphics[width=0.5\textwidth]{./figures/design_pattern/qpu_abstraction.pdf}
  \caption{A conceptual depiction the QPU model.}
  \label{fig:qpu_abstraction}
\end{figure}

\medskip
\noindent
\textbf{Query interface.}
Query processing units expose an interface for receiving query requests.
This interface is common among all QPU classes.
As a result, a QPU can send query requests to other QPUs, regardless of their class.
This is the mechanism with which QPUs interoperate to perform query processing tasks,
and forms the basis of the query processing system's computation model (section~\ref{sec:computation_model}).

However different QPUs may be able to process only a subset of the queries that can be expressed by the interface's query
language.
For example, a QPU may only serve queries about a specific database table.
We call the set of queries that a unit can process its \textit{query processing capabilities}.

The QPU's query interface has \textit{streaming semantics}.
An invocation of the query interface initiates a stream between the QPU that sent the query request and the one that
received it;
the results of the query are sent as records through that stream.

We present the query interface in more detail in section \ref{ref:query_interface}.

\medskip
\noindent
\textbf{State.}
Each QPU maintains \textit{internal} state, that is accessible only by that QPU.

We distinguish the QPU state in three parts according to its functionality.
Each query processing unit maintains \textit{configuration state} that represents the query processing unit's
configuration parameters.
Moreover, QPUs that have downstream connections maintain information about these connections, which is
used for generating downstream query requests.
We call this part of the state \textit{local graph view}.
Finally, query processing units that implement derived state structures and QPUs that store intermediate query processing
results, for example in streaming join computations, maintain \textit{query processing state}.

\medskip
\noindent
\textbf{Initialization, query processing, and input stream callback function.}
The functionality of a query processing unit can be modeled using three functions:
\begin{itemize}
  \item The \textit{initialization function} (section~\ref{sec:initialization_func}), which is executed when the QPU is
  initialized.

  \item The \textit{query processing function} (section~\ref{sec:query_processing_func}), which is executed for each
  query request received by the QPU, and is responsible for processing the query and sending results to the response stream.

  \item The \textit{input stream callback function} (section~\ref{sec:callback_func}), which is executed for each record
  received through an input stream.

\end{itemize}

The QPU model defines the signatures of these functions, but a specific implementation.
Each QPU class provides implementations for these functions.

\bigskip

A conceptual depiction of the query processing unit model is shown in Figure~\ref{fig:qpu_abstraction}.
When the QPU's query API is called, an output stream ($R_A$) is established between the unit and the sender,
and the unit's query processing function is invoked for the given query.
The query processing function can read the QPU's state, and can perform downstream queries to other units.
For each downstream query, a corresponding stream is established ($Q_{A.1}$ and $Q_{A.2}$).
When a record is received from one of the streams, the QPU's callback function is invoked.
Each invocation of the callback function processes a received record, and returns the result to the query processing
function.
Upon receiving a result from a callback function,
the query processing function can potentially write to the QPU's state and/or emit a record to the output stream.


\subsection{Query Processing Unit component model specification}
\label{ref:specification}

In this section we present the detailed specification of the query processing unit component model.

\subsubsection{Query interface}
\label{ref:query_interface}
% we first present a high level overview of the QPU model's interface, and then describe each of its elements in more detail.

Query processing units expose an interface for receiving query requests:

\begin{displaymath}
  Query(QueryRequest) \rightarrow QueryResponse
\end{displaymath}

\begin{itemize}
  \item $QueryRequest$ specifies a predicate on the data items' \textit{attributes}, and a \textit{time interval}.

  \item $QueryResponse$ is a stream containing the query's results.
\end{itemize}

\noindent
\textbf{Query results as updates}.
$QueryResponse$ records represent \textbf{updates} to the corpus (an update can be a creation, modification, or deletion
of a data item).
Updates are represented as \textit{deltas}:
a delta representing an update $u$ to a data item $d$ contains the values of $d$'s attributes before $u$ is applied,
and those after $u$ is applied.

More specifically:
\[
  QueryResponse = [StreamRecord]
\]
where
\[
  StreamRecord =
\]
\[
  (DataItemID,~[(AttributeName,~AttributeValue_{old},~AttributeValue_{new})],~Timestamp)
\]

\begin{sloppypar}
An $update$ is a triplet containing
(1) the primary key of the data item ($DataItemID$) it refers to,
(2) a list of triplets of the form $(AttributeName, AttributeValue_{old}, AttributeValue_{new})$ that represent the
data item's attribute values before and after the update is applied,
and (3) the timestamp ($Timestamp$) assigned to the update.
\end{sloppypar}

\medskip
\noindent
\textbf{The query request's time interval.}
Given a $QueryRequest$ that specifies an attribute predicate $Pred$ and a time interval $T$ $=$ $[t_1, t_2)$
\begin{itemize}

  \item if $t_1$ $<$ $t_2$,
  $QueryResponse$ contains any update $u$ with $t_1$ $\leq$ $timestamp$ $<$ $t_2$,
  and for which one of the following is true:
  \begin{itemize}
    \item $u$ creates a data item $d$, and $d$'s attributes satisfy $Pred$.
    \item $u$ deletes a data item $d$, and $d$'s attributes satisfied $Pred$ before deletion.
    \item $u$ modifies a data item $d$, and $d$'s new attribute values after $u$ is applied satisfy $Pred$.
    \item $u$ modifies a data item $d$, and $d$'s old attribute values before $u$ is applied satisfy $Pred$.
  \end{itemize}
  We term this type of query \textit{an interval query}.

  \item If $t_1$ $=$ $t_2$ = $t$,
  then among the set of all updates that the condition stated above,
  $QueryResponse$ contains for each data item \textit{the update with the latest timestamp before $t$}, i.e:

  $\nexists$ $u':$ $timestamp'$ $>$ $timestamp$ $\land$ $timestamp'$ $\leq$ $t$

  We term this type of query a \textit{snapshot query}.

\end{itemize}

By returning the latest update before a given timestamp $t$,
a snapshot query effectively returns the \textit{state} of each data item that satisfies $Pred$ at $t$.
Therefore, a snapshot query refers to a \textit{snapshot} of the corpus that contains the effects of all update with
$timestamp$ $<$ $t$.

In contrast, an interval query returns may return multiple updates for a specific data item,
which have timestamps within the specified time interval and modify the data item so that either is starts of it stops satisfying $Pred$.

By using a upper bound ($t_2$) in the future (a timestamp that the system has not yet reached),
an interval query can continue receiving future updates that satisfy $Pred$.
This provides a mechanism for \textit{subscribing to notification for updates}.

\bigskip

\textbf{Query Language.}
% https://documentation.basis.com/BASISHelp/WebHelp/usr2/sql_grammar.htm
% http://www.h2database.com/html/grammar.html#expression

The query processing unit interface support a query language with an SQL-like syntax.
The query language supports point and range queries, logical operators, aggregation functions, and joins.
We argue that these is no inherent limitation in the QPU model that prevents it from supporting a more complex
query language (for example supporting nested queries).
However, we consider additional functionalities to be out of the scope of this work.
We believe this query language can effectively demonstrate that the QPU model can be used as building
block for constructing fully-functional query processing systems.

\medskip
\noindent
The QPU model's query language has following syntax:

{\obeylines\obeyspaces
\texttt{
QueryRequest          ::=  SELECT SelectExpression
~~~~~~~~~~~~~~~~~~~~~~~~~~~FROM TableExpression
~~~~~~~~~~~~~~~~~~~~~~~~~~~WHERE PredicateExpression
~~~~~~~~~~~~~~~~~~~~~~~~~~~TIMESTAMP TimestampExpression \todo{the timestamp can be just another attribute, but I think we need to have it separate for emphasis}
~~~~~~~~~~~~~~~~~~~~~~~~~~~[ GROUP BY attributeName ]
~~~~~~~~~~~~~~~~~~~~~~~~~~~[ ORDER BY OrderByExpression \{ ASC | DESC \} ]
}}

{\obeylines\obeyspaces
\texttt{
SelectExpression      ::=  ALL
~~~~~~~~~~~~~~~~~~~~~~~~~~~SelectExpressionItem , SelectExpression |
~~~~~~~~~~~~~~~~~~~~~~~~~~~SelectExpressionItem
}}

{\obeylines\obeyspaces
\texttt{
SelectExpressionItem  ::=  SUM(attributeName) | AVG(attributeName) |
~~~~~~~~~~~~~~~~~~~~~~~~~~~MAX(attributeName) | MIN(attributeName) |
~~~~~~~~~~~~~~~~~~~~~~~~~~~attributeName
}}

{\obeylines\obeyspaces
\texttt{
TableExpression       ::=  tableName JoinType tableName On tableName.attributeName = tableName.attributeName |
~~~~~~~~~~~~~~~~~~~~~~~~~~~tableName
}}

{\obeylines\obeyspaces
\texttt{
JoinType              ::=  \{ INNER | \{ LEFT | RIGHT \} OUTER \} JOIN
}}

{\obeylines\obeyspaces
\texttt{
PredicateExpression   ::=  PredicateExpression OR PredicateExpression |
~~~~~~~~~~~~~~~~~~~~~~~~~~~PredicateExpression AND PredicateExpression |
~~~~~~~~~~~~~~~~~~~~~~~~~~~NOT PredicateExpression |
~~~~~~~~~~~~~~~~~~~~~~~~~~~Term Op Term
}}

{\obeylines\obeyspaces
\texttt{
Term                  ::=  attributeName | Value
}}

{\obeylines\obeyspaces
\texttt{
Op                    ::= > | >= | < | <= | = | !=
}}

{\obeylines\obeyspaces
\texttt{
Value                 ::= stringValue | floatValue | intValue |
~~~~~~~~~~~~~~~~~~~~~~~~~~dateTimeValue | timestampValue
}}

{\obeylines\obeyspaces
\texttt{
OrderByExpression     ::= attributeName , OrderByExpression |
~~~~~~~~~~~~~~~~~~~~~~~~~~attributeName
}}

{\obeylines\obeyspaces
\texttt{
TimestampExpression   ::= FROM TimestampTerm [ TO TimestampTerm ]
}}

{\obeylines\obeyspaces
\texttt{
TimestampTerm         ::= SYSTEM START | LATEST | timestampValue
}}

~ \bigskip

In practice, each QPU instance can only process a subset of the queries that can be expressed by this query language,
according to the functionality supported by its class.
For example, a QPU class that implements a join operator can perform join over two input streams,
but not evaluate a $PredicateExpression$, or perform an $SUM$ on an attribute of the join result.
This can be achieved by connecting ``join'', ``filter'', and ``aggregator'' QPUs.
We present in detail these QPU classes in section~\ref{sec:qpu_classes},
and how they are composed to provide complex query processing functionalities in section~\ref{sec:query_processing_system}.

Moreover, instances of a certain class may support different parts of the query language according to their
configuration.
For example, two instances of a filter operator QPU class may support predicate queries for different tables.

\subsubsection{QPU State}

The query processing unit's state is divided into the following parts:

\medskip
\noindent
\textbf{Configuration state.}
Upon initialization, each QPU receives is given a set of configuration parameters.
These parameters are represented as key-value pairs.
The configuration state represents these parameters.

Configuration parameters can be divided to the following parts:
\begin{itemize}
  \item Topology configuration.
  This part of the configuration consists of the endpoints of the QPU's downstream connections in the QPU graph.

  \item Class-specific configuration.
  The part of the configuration specifies parameters such as cache size or the definition of a materialized view.
\end{itemize}

% \begin{lstlisting}[caption={Pseudocode for the QPU's configuration state},captionpos=b,label={lst:qpuconfigstate}]
% class ConfigurationState
%   function GetConfigParameter(Key) ConfigParameterValue
% \end{lstlisting}

\medskip
\noindent
\textbf{Local graph view.}
For each of its downstream connections, a query processing unit maintains a data structure that represents the
\textit{set of queries that this connection can process}, which we term \textit{query processing capabilities}.
It the query processing capabilities of its neighbors in order to: (1) validate if it can process a given
query, and (2) generate downstream queries for a given query.

The data structures for the query processing capabilities of a QPU's downstream connections compose it local graph view
state.

In section~\ref{sec:qpc_tree} we present query processing capabilities data structure as well as its use in detail.

\medskip
\noindent
\textbf{Query processing state.}
Query processing units that encapsulate derived state structures such as indexes, materialized views and
caches, store these data structures in the part of their state that we call \textit{query processing state}.
Additionally, streaming operator QPUs such as joins use this part of the state to store intermediate state.

We model the query processing state as set of key/value, ordered by key;
Keys are string values, and values are lists of data items, represented as:
\[
  (DataItemID, [(AttributeName, AttributeValue, AttributeValue)], Timestamp)
\]

Using pseudocode, we can represent the query processing state's API as follows:

\begin{lstlisting}[caption={Pseudocode for the QPU's query processing state},captionpos=b,label={lst:qpustate}]

type AttributeName string

type AttributeValue union {
  string
  float
  int
  dateTime
  timestamp
}

type StreamRecord {
  dataItemID  string
  attributes  [(AttributeName, AttributeValue, AttributeValue)]
  ts          timestamp
}

class QueryProcessingState
  function Get(Key_low, Key_high) [(Key, [StreamRecord])]
  function Put(Key, [StreamRecord])

\end{lstlisting}

$Get$ retrieves the query processing state entries with $Key_low$ $<$ $key$ $\leq$ $Key_high$.
$Put$ modifies the value of the query processing state for a given key.
Put can be used with a non-existing key to create a new entry, or with an empty value to delete an entry.


\subsubsection{Initialization function}
\label{sec:initialization_func}

Each QPU invokes an initialization function when it starts its execution.

\begin{lstlisting}[caption={Initialization function signature},captionpos=b,label={lst:init_func}]
type DownstreamConnection {
  endpoint sting
  capabilities QPCapabilities
}

function Init(QPState, [DownstreamConn])
\end{lstlisting}

\noindent
Listing~\ref{lst:init_func} shows the initialization function's signature.
$ProcessQuery$ receives as arguments:
\begin{itemize}
  \item $QPState$, which is a handler that enables $Init$ to read from and write to QPU's query processing state.

  \item A list of $DownstreamConn$, each consisting of the endpoint of a downstream connection and a data structure
  representing the connection's query processing capabilities (section~\ref{sec:qpc_tree}).
  $Init$ can therefore send downstream query requests.
\end{itemize}


\subsubsection{Query processing function}
\label{sec:query_processing_func}

The query processing function is responsible for processing a given query and emitting the results to the output stream.

For each query $q$ being processing, the QPU initiates an output stream, $R_q$,
and executed an instance of the query processing function, $QPF_q$.
$QPF_q$ is responsible for emitting records to $R_q$.
Moreover, if $QPF_q$ initiates input streams $I_{q-1}$, $I_{q-2}$, ..., then $QPF_q$ is responsible for handing the return
values of callback functions for records received through $I_{q-i}$.

\begin{lstlisting}[caption={Query processing function signature},captionpos=b,label={lst:query_processing_func}]
function ProcessQuery(QueryRequest, QPState, [DownstreamConn],
                      ResponseStream)
\end{lstlisting}

\noindent
\begin{sloppypar}
Listing~\ref{lst:query_processing_func} shows the query processing function's signature.
In addition to $QPState$ and $[DownstreamConn]$, $ProcessQuery$ receives:
\end{sloppypar}
\begin{itemize}
  \item $QueryRequest$, which represents the received query request.

  \item $ResponseStream$, a handler it can use to emit result to the output stream.

\end{itemize}

An instance of the query processing function is executed for each received query request,
therefore query processing unit can run multiple instances of the query processing function in parallel.

\subsubsection{Input stream callback function}
\label{sec:callback_func}

The input stream callback function is responsible for processing a record received through an input stream.
The callback function can read from and write to the query processing unit state,
and a (potentially empty) list of $StreamRecord$ to the query processing function.

\begin{lstlisting}[caption={Input stream callback function signature},captionpos=b,label={lst:callback_func}]
function ProcessInputRecord(StreamRecord, QPState, DownstreamConn)
          returns [StreamRecord]
\end{lstlisting}

\noindent
Listing~\ref{lst:callback_func} shows the query processing function's signature.

An instance of the callback function is executed for each record received through an input stream.


\subsection{QPU classes}
\label{sec:qpu_classes}

As described in the previous section, the query processing unit model has the role of ``template'',
defining unified semantics that every QPU conforms with.
This ensures that query processing units can be arbitrarily interconnected and interoperate to implement query processing
tasks.

A QPU class is an \textit{instantiation} of the query processing unit model, which defines implementations for
the \textbf{query processing function} and the \textbf{input stream callback function}.

In this section, we present a categorization of QPU classes according to their general characteristics,
and demonstrate some specific examples of QPU classes.
We intentionally do not present a more extended list of QPU classes as it is out of the scope of this chapter.
We present additional QPU classes in chapters~\ref{ch:case_studies}, \ref{ch:proteus}, \ref{ch:evaluation}.

We categorize QPU classes in three groups, according to their general characteristics:
\begin{itemize}
  \item \textbf{Relational operator QPUs}.
  Classes in this group can be viewed as \textit{streaming relational operators}.
  They receive input data streams and perform filtering or transformation of these streams.
  Every input stream record, results in the QPU emitting zero or one records in the output stream.

  Conforming to the QPU specification, every input stream is the output stream of another QPU,
  and every output stream is the response to a query request.

  Some examples QPU classes in this group are:
  \begin{itemize}
    \item \textbf{Filter:}
    A filter QPU implements a streaming filter operator.
    \todo{more details in example}
    \item \textbf{Join}:
    A join QPU implements a streaming join operator.
    Given a query with a join operator,
    the join QPU is responsible for initiating input streams by sending the appropriate query requests to downstream QPUs,
    performing a streaming join operation on the input streams, and emitting the result at its output stream.
    \item \textbf{Aggregator}:
    An aggregator QPU implements a aggregation function over an input stream, such as count, sum, average, min or max.
    The aggregator QPU emits an record at the output stream for each input record that changes the aggregation value.
  \end{itemize}

  \item \textbf{Derived state QPUs}.
  Classes in this group implement derived state structures, such as indexes, caches, and materialized views.

  QPU classes of this group make use of the same use of the ``query request - output stream'' semantics to implement
  their functionality:
  \begin{itemize}
    \item \textbf{Secondary index and Materialized View:}
    An secondary index (or materialized view) QPU initiates an input steam by sending a query request with an \textit{interval query without
    an upper bound timestamp}.
    In that way, the QPU effectively \textit{subscribes to notifications} for updates to the corpus.

    For each input record, the QPU's callback function updates the QPU's query processing state accordingly.
    When receiving a query request, the unit computes the results by reading from its query processing state,
    and emits them to the output stream.

    For simplicity we assume that a secondary index QPU maintains an index for a single attribute
    (and the same for materialized view QPUs respectively).

    
    \item \textbf{Cache:}
    A cache QPU stores query results at its query processing state.
    When receiving a query request, the QPU's query processing function first determines it has stored the query result,
    and if yes it retrieves and emits it at the output stream.
    Alternatively, the query processing function sends query request at a downstream connection, forwarding the same query.
    The callback function the stores each received record at the query processing state, and then emits it at the output
    stream.
    \end{itemize}

  \item \textbf{Routing QPUs}.
  Classes of this group are responsible for implementing higher level functionalities, such as coordinating partitioned or
  replicated derived data structures, or performing load balancing.

  Examples of classes in this group include:
  \begin{itemize}
    \item \textbf{Partition manager:}
    A partition manager QPU is responsible for managing access to set of QPUs that implement index or materialized view
    partitions.
    The unit has outgoing edges in the QPU graph to a number of partitions.
    It also maintains at its connection's capabilities state information about the partitioning scheme and the portion of
    the partitioned space that each of its connections corresponds to.

    When receiving a query request, the QPU's query processing function uses these information to determine which
    partitions need to be contacted for the given query,
    and sends query requests to the corresponding downstream connections.
    The QPU then combines the resulting input streams and emits the combined stream as its output stream.

    \item \textbf{Load balancing and replica manager:}
    QPUs of these classes have similar functionalities with the partition managers:
    given a query they select the most suitable among their downstream connections, according to a certain criterion specific
    to each class, forward the given query, and finally forward the resulting input stream to their output stream.

    \end{itemize}

  \item \textbf{Database driver QPUs}
  The database driver class is responsible for connecting the QPU graph with the corpus.
  It is particular class, as database driver QPU do not support downstream connections to other QPUs.
  As a result they are located at the leaves of the QPU graph.

  Database driver QPUs apply a restriction on the query language.
  Their query interface supports queries of the form:
  {\obeylines\obeyspaces
  \texttt{SELECT SelectExpression from TableName TIMESTAMP TimestampExpression}}

  Given a query, the query processing function uses the interface and mechanisms of they corpus database in order to generate and emit
  the output stream.

  Database driver QPUs acts as wrappers that expose a common interface and semantics --- those defined by the QPU model --- to the
  QPU graph, independent of how the corpus is stored and accessed.

  As a result database driver classes are database-specific.
  QPU-based query processing systems are compatible with any corpus database as long as there is a corresponding database driver class
  to provide the interface with that database.
\end{itemize}

\subsubsection{QPU class case studies}

\textbf{Filter}


% % \begin{algorithm}
% % \caption{Query processing function signature}
% % \label{func:query_processing}
% % \begin{algorithmic}
% % \Function{ProcessQuery}{QueryRequest, State, DownstreamNeigbors, ResponseStream}
% % \end{algorithmic}
% % \end{algorithm}
% Every QPU implements a function that is responsible for processing queries request received by the QPU.
% The query processing function is the core to the query processing unit's functionality.
% As different QPU classes have implement different functionalities, the query processing function's implementation is
% class-specific.



\bigskip
\noindent
\textbf{Secondary index}


\section{QPU-based query processing systems}
\label{sec:query_processing_system}

\subsection{Query processing system architecture}

\begin{figure}[t]
  \centering
    \includegraphics[width=0.4\textwidth]{./figures/design_pattern/qpu_graph_emergent_properties.pdf}
  \caption{QPU graph example}
  \label{fig:qpu_graph_emergent_properties}
\end{figure}

A \textit{QPU-based} query processing system is a directed acyclic graph (DAG).
Graph nodes are query processing unit instances.
Edges represent potential query request - response steam relations between QPUs.
A directed edge from $QPU_a$ to $QPU_b$ indicates that $QPU_a$ can send query requests to $QPU_b$.
When $QPU_a$ sends a $QPU_b$ a query request to $QPU_b$, a stream of query results with the opposite direction is established between them.

Leaf nodes (nodes with no outgoing connections) are always database driver QPUs.
Queries enter the QPU graph through root node (nodes with no incoming connections).
\todo{ref}

The capabilities of a QPU-based query processing system are emergent from the functionalities of the QPUs at its node, as well as the
graph topology.
For example, consider the QPU graph depicted in Figure~\ref{fig:qpu_graph_emergent_properties}:
\begin{itemize}

  \item $DB$ $driver_1$ can process queries with the form:
  {\obeylines\obeyspaces
  \texttt{SELECT SelectExpression from Patients TIMESTAMP TimestampExpression
  }}
  where $SelectExpression$ can contains one or more attributes of the $Patients$ table.

\item $DB$ $driver_2$ can process queries with the form:
{\obeylines\obeyspaces
\texttt{SELECT SelectExpression FROM KnowledgeBase TIMESTAMP TimestampExpression
}}
where $SelectExpression$ contains one or more attributes of the $KnowledgeBase$ table.

\item $Filter_1$ can send downstream queries to $DB$ $driver_1$
and apply a filter to its input stream.
Therefore, $Filter_1$ can process queries of the form:
{\obeylines\obeyspaces
\texttt{SELECT SelectExpression FROM Patients
        WHERE PredicateExpression
        TIMESTAMP TimestampExpression
        }}
where $SelectExpression$ and $PredicateExpression$ can use attributes of the $Patients$ table.

\item Similarly, $Filter_2$ supports queries of the form:
{\obeylines\obeyspaces
\texttt{SELECT SelectExpression FROM KnowledgeBase
        WHERE PredicateExpression
        TIMESTAMP TimestampExpression
        }}
where $SelectExpression$ and $PredicateExpression$ can use attributes of the $KnowledgeBase$ table.

\item $Join$ can send downstream queries to $Filter_1$ and $Filter_2$
and join the two input streams based on a given attribute.
Assuming that the $Patients$ and $KnowledgeBase$ tables have a common attribute, $symptoms$,
$Join$ can process queries of the form:
{\obeylines\obeyspaces
\texttt{SELECT SelectExpression
        FROM Patients JOIN KnowledgeBase ON Patients.symptoms = KnowledgeBase.symptoms
        WHERE PredicateExpression
        TIMESTAMP TimestampExpression
        }}
where $SelectExpression$ and $PredicateExpression$ uses attributes from both tables.

\end{itemize}

\todo{ref}

\subsubsection{QPU-graph topology rules}
topology cannot be arbitrary

rules that stem from the query processing units' functionalities

non-exhaustive list,
For each QPU class can be generalized to two types of rules:
(1) number of downstream connections, and (2) the \textit{query processing capabilities} of the downstream connection

\begin{itemize}
  \item All QPU graphs mush have database driver QPUs as their leaves.
  Database drivers generate the initial streams that any other QPU builds on.

  \item Most QPUs in the relational operator and derived state groups must have a single downstream connection.
  Exception consists relational operator QPUs that by definition operate on more that one input streams, such as join QPUs.

  \item A materialized view QPU must have a downstream connection that can provide a stream of updates on the query
  that defines the materialized view
  In more detail, the downstream connection of a materialized view QPU must be the root of a subgraph that
  \begin{itemize}
    \item Can process the query the is the materialized view's definition.
    \item Supports \textit{interval queries} on that query.
  \end{itemize}
  \todo{use existing example}

  \item Similarly, a secondary index QPU must have a downstream connection that can provide a stream of updates on the
  attribute that QPU is configured to index.

  \item A cache QPU must have at least on downstream connection.
  This connection can be towards any valid sub-graph.

  \item Similarly, a filter QPU can be connected to any valid sub-graph.

  \item A partition manager QPU must have one or more downstream connections to derived state QPUs that implement
  partitions of a derived state structure.
  In more detail:
  \begin{itemize}
    \item All downstream connection must be of the same QPU class

    \item They must be configured as partitions of a logical global derived structure, based on a single partitioning key.
  \end{itemize}

  \item A load balancer QPU must have one or more downstream connections, and the \textit{intersection} of the queries
  supported by these downstream QPUs must be non empty.
  Because any of the downstream QPUs can process the queries at the intersection of their supported queries, the load
  balancer QPU can perform distribute these queries among its downstream connections.
\end{itemize}

\subsection{Computation model}
\label{sec:computation_model}

% In this section we present how QPU-based query processing systems process queries.
% We first present an overview of the computation model \ref{sec:computation_model}, and then ...

The query processing unit computation model combines elements from microservice architectures and stream processing systems.
Similar to stream processing systems,
query processing units operate on input streams either to incrementally update their state, or to perform query processing
computations.
Similar to microservices architectures, any stream is initiates as a response to a \textit{service request}.

\medskip

The computation run by a QPU-based query processing system directly emerges from the QPU specification.
We describe this collective computation by describing the execution of a generic query $q$ by a QPU graph.
Given a query $q$, the query processing function of a QPU $Q$ at the root of a QPU graph sends query request to
downstream connection in order to initialize input stream required for processing the query.
The QPU performs a computation on the input streams, potentially also involving its state, and emits the results at its
output stream.
The same process is performed at each of the downstream connection of $Q$, and their downstream connection, propagating
downwards through the QPU graph.
This creates a \textit{query execution sub-graph} composed of the QPUs that participate in the processing of $q$.

The leaves of this sub-graph are QPU that can process their given queries without sending downward query requests.
This includes database driver QPUs, and derived state QPUs.
These QPUs become the leaves of $q$'s execution sub-graph.
Leaf QPUs produce output streams that are then received as input stream at \textit{upstream QPUs}.
Progressively, each non-leaf QPU in the query execution sub-graph receives an input stream for each query request sent,
and produces itself an output stream.
Finally, $Q$ calculates the response for $q$ and emits it as its output stream.
We call this type of QPU graph computation \textit{query execution mode}.

\medskip
our ````````````````````````''''''''''''''''''''''''
The same process is performed for incrementally updating secondary index and materialized view QPUs (\textit{state maintenance mode}).
There are the following differences between query execution mode and state maintenance mode:
\begin{itemize}
  \item Query execution happens in response to a client query,
  while state maintenance happens in response to the initialization of a secondary index of materialized view QPU.
  \item The goal of query execution is to process a client query,
  while the goal state maintenance is to establish a long running stream of notification for corpus updates.
  \item The root of a query execution sub-graph is one the QPU graph root nodes,
  while the root of a state maintenance sub-graph is a derived state QPU.
\end{itemize}

\medskip

Based on the above description, the computation run of a QPU-based processing system can be characterized as a
\textit{bi-directional dataflow computation}.
For a given query or state maintenance execution,
query requests flow downwards through the QPU graph, defining an execution sub-graph.
Response streams flow upwards through that sub-graph, each stream corresponding to an edge defined by a query request.

\medskip

Finally, query processing units are multi-threaded:
a QPU can process multiple queries in parallel.
Therefore, multiple different query execution and state maintenance sub-graph can co-exist in parallel in the same QPU
graph.

\subsection{Query execution}

\subsubsection{Query parse tree}

The first of a QPU's query processing function is to parse the query request to a form that can be used for query processing.
This form is a \textit{parse tree}.

A parse tree is constructed by applying the QPU query language's grammar to a given query string.
More specifically, a parse tree is composed to three types of nodes:
\begin{itemize}
  \item \textbf{Atoms}, which include keywords of the query language ($SELECT$, $FROM$ etc.),
  identifiers, such as table or attribute names, constants, operators and tokens.
  Atoms are leaf nodes of the parse tree.

  \item \textbf{Syntactic categories}, which are constructs built from other syntactic categories, or atoms,
  follow the query language's grammar rules ($SelectExpression$, $TableExpression$ etc.)
  Syntactic categories are internal nodes of the parse tree
\end{itemize}

Given a query string $s$, a parse tree is constructed by parsing $s$ using the query language grammar rules.
\todo{ref parsing algorithms}

\subsubsection{Query processing capabilities tree}
\label{sec:qpc_tree}

In this section we present the \textit{query processing capabilities tree} (QPC tree)
The QPC tree represents the \textbf{set of all query parse trees that a QPU can process}.

To achieve that, we introduce an additional typo of tree node, the \textbf{conjunction} \todo{better name??}.
Conjunction nodes essentially express the different branches of a syntax rule.
For example, the rule:
{\obeylines\obeyspaces
\texttt{
PredicateExpression  ::=  PredicateExpression OR PredicateExpression |
~~~~~~~~~~~~~~~~~~~~~~~~~~PredicateExpression AND PredicateExpression |
~~~~~~~~~~~~~~~~~~~~~~~~~~NOT PredicateExpression |
~~~~~~~~~~~~~~~~~~~~~~~~~~Term Op Term
}}

can be represented as \todo{do the tree}.


.. Present the trees in the orders example ..

Each QPU has a QPU tree, which is parts of its configuration state.
Stores the QPC trees of its neighbors as part of its local view state.

It is used for two purposes
\begin{itemize}
  \item The QPU uses determines if it can process a given query by the parse tree of the given query ``fits'' its QPC tree.
  \item The QPU generates downstream query requests using the QPC trees of its downstream connections, by performing a
  trimming operation.
\end{itemize}




% Given $q$, the query processing function of a QPU $Q$ at the root of the QPU graph sends query request to some its
% downstream connection, in order to initialize input stream required for processing the query.
% Upon receiving a query request from $Q$, each of its downstream connection performs the same process.
% In that way, query requests are propagated downwards through the QPU graph, creating a \textit{query execution sub-graph}
% composed of the QPUs that participate in the processing of $q$.

% As query requests requests are propagated downwards, expanding the $q$'s execution sub-graph, eventually some QPUs can
% process their queries without sending further query requests downwards.
% This occurs in database driver and derived state QPUs.
% The leaves of this sub-graph are QPU that can process 
% This includes database driver QPUs, and derived state QPUs.
% These QPUs produce output streams that are then processed as input stream at \textit{upstream QPUs}.

% Progressively, each non-leaf QPU in the query sub-graph receives an input stream for each query request sent,
% and produces it self an output 


% We describe how a QPU graph processes a given query using the example of Figure~\ref{fig:qpu_graph_emergent_properties}.

% Consider the query:
% {\obeylines\obeyspaces
% \texttt{Q = SELECT CustomerName, CustomerEmail, OrderID
%         ~~~~FROM Customers
%         ~~~~INNER JOIN Orders ON Customers.OrderID = Orders.OrderID
%         ~~~~WHERE Orders.OrderDate >= 2020-08-20 AND Orders.OrderDate < 2020-09-02
%         ~~~~TIMESTAMP FROM LATEST TO LATEST
%         }}





% - queries / control messages flow downwards.
% - responses flow upwards through the sub-graph defined by the queries
% - (each query establishes a sub-graph - actually a tree - to be used by that particular query);
% - Updates (independently) also flow upwards

% As described in the previous sections, query processing units can collaborate by invoking the query API of one another.
% QPUs can be composed in DAG hierarchies in which parent units can invoke the query API of their child units.
% Query responses for both snapshot and persistent queries are streams of results.
% Communication between QPUs thus uses a combination of the remote procedural call model (query API invocations) and the stream-processing model (query responses).

% Clients perform queries by invoking the query API of units at root nodes of the graph.
% Once a QPU receives a query, it determines whether it can directly process it, for example by performing lookups at its indexing structures,
% and if that is the case it responds with the query result.
% In case the query processing computation requires partial query results from its child units, the unit invokes the query API of those units with the appropriate sub-queries.
% Sub-query results are received and processed through the unit's callback function.

% This process is recursively performed at each query processing unit.

% Therefore, the computation that runs in QPU a graph can be modeled as a bidirectional data-flow computation.
% Queries flow downwards through the graph, are incrementally split into sub-queries, and processed across the graph.
% Sub-query results flow back upwards, are incrementally processed, and eventually produce the results to the initial query.

% The same computation model is used for index maintenance.
% We have extended the query interface semantics so that the query API can be used to subscribe to notifications for corpus updates, and query results can encode these updates.
% Using this mechanism, units with indexing functionalities can subscribe to corpus updates by invoking the query API of QPUs that provide this functionality.
% We describe this mechanism in more detail in Section \ref{subsec:query_classes}.


% The QPU graph runs a distributed bidirectional data-flow computation.

% A client performs a query $Q_c$ by invoking the query API of a query processing unit at the root of the graph.
% As described in Section~\ref{subsec:qpu}, the QPUs query processing computation can read from the unit's state,
% or perform downstream queries to QPUs at its child nodes.

% When a downstream query is performed, this process is recursively executed at each unit whose query API is invoked.
% Though this mechanism, $Q_c$ is incrementally transformed to sub-queries which flow downwards through the QPU graph,
% invoking computations at different nodes.
% Sub-query results are returned through the QPU streams established from query API invocations, and flow upwards
% through the graph.
% These results are incrementally processed, potentially updating the state of different QPUs, and eventually
% produce the initial query results, which are returned to the client.









% \section{QPU Composition: Constructing QPU-based query engines}
% Here, describe how query engines are constructed using instances of QPU classes.

% A query engine is a directed acyclic graph (why?) with QPUs as nodes.

% Describe the QPU-specific topology properties that the graph must satisfy in
% order to be functional:
% \begin{itemize}
%   \item All leaves must be QPUs of the datastore driver class.
%   Also, datastore driver QPUs cannot be nodes other than leaves.
%   \item TODO
% \end{itemize}

% \section{Computation Model}
% Describe the bidirectional data-flow computation.
% \begin{itemize}
%   \item Control messages (queries) flow downwards.
%   \item Responses flow upwards through the sub-graph defined by the control
%   (each query establishes a sub-graph - actually a tree - to be used by that
%   particular query);
%   \item Updates (independently) also flow upwards.
% \end{itemize}


% % \section{The consistency guarantees of QPU-based query engines}
% % TODO: What mechanism are needed so that QPUs can guarantee internal consistency?
% % What about session consistency guarantees?

% \section{Discussion}

% discussion: input output disconnected here
    % discussion: input output disconnected here

% % -- point to make -- unified subscription and snapshot and routing
% graph topology is distributed

% % It is known that query execution can be represented as a tree.
% % Base data are at the tree's leaves, tree nodes are relational operator such
% % as filter, joins and aggregations, and query result are at the root of the tree.
% % Each operator receives an input stream of records, performs a transformation on the, and emits a output stream of record.
% % This results to a data-flow computation in which data items flow upwards through the tree and are progressively transformed
% % to the query execution results.

% % Computation tasks vs architecture components

% % Our approach is based on three simple insights:
% % \begin{itemize}
% %     \item \textbf{Index-based distributed query processing is composed of basic, primitive tasks.}
% %     The most simple query engine design is a component that scans the corpus dataset and selects the data items which match a given query.
% %     When queries for certain attributes are frequent or require low response time, secondary indexes can be materialized for those attributes.
% %     Even when indexes are partitioned and distributed across the system for scalability, the basic components of an indexing system remains the same: index data structures that collaborate through appropriate index maintenance and query processing protocols to implement distributed indexes.
% %     Additional query processing functionalities such as multi-attribute queries, joins or federated queries across multiple corpus can be implemented using operators that build on top of these components.
% %     Finally, caching can be used to further improve response time for certain queries.

% %     \item \textbf{Primitive query processing tasks can be encapsulated by a common query processing component model.}
% %     Each of the described tasks can be encapsulated by a query processing component model with two properties: an API for responding to queries, and a callback function.
% %     For example, index data structures in general implement three basic functions: LOOKUP, INSERT, DELETE.
% %     The query API can encapsulate the LOOKUP function, while the callback function can express the task of index maintenance, receiving corpus updates and updating the index accordingly, and therefore encapsulate INSERT and DELETE.
% %     As another example, a cache on top of an index structure should be able to respond to the same queries as the underlying index, and therefore can be encapsulated by a query processing component with the same query API.
% %     Similarly, its callback function can express the task of receiving query results in case of a cache miss, and updating the cache.
% %     This concept can be generalized to represent other query processing components including bloom filters, materialized views, and streaming operators.

% %     \item \textbf{Query processing components need to cooperate to implement complex query processing tasks.}
% %     As an example, a caching component requires the ability to forward queries to other components, such as indexes, when cache misses occur.
% %     Similarly, a distributed indexing system, in which indexes are partitioned and distributed across system nodes, can be implemented using indexing components with the help of an additional component responsible for implementing a partitioned LOOKUP operation, by collecting and aggregating partial LOOKUP results.
% % \end{itemize}

% % Based on these observations, we introduce a query processing component model, called the \textit{Query Processing Unit} (QPU).
% % We have designed a generic query API and callback function interface with the aim of encapsulating multiple different query processing components.
% % Query processing units may have internal state for facilitating query processing, or be stateless.
% % Additionally, QPUs have the ability to invoke the query API of one another, and thus interoperate for query processing.


\bibliographystyle{plainnat}
\bibliography{refs}